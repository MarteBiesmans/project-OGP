extra uitleg bij arrays: https://www.youtube.com/watch?v=1q3brvLgYbs

in unit mss best een onderverdeling maken in unitWeight/carriedWeight/totalWeight
we hebben ze niet alle 3 nodig, maar ik weet nog niet welke de minste aanpassingen nodig heeft voor de rest
want hun eigen gewicht moet aan voorwaarden voldoen en het totale gewicht bepaalt hun bewegingen
	-> ik heb een functie gemaakt getTotalWeight(), wat ik van de opdracht opmaak is dat dit alleen de snelheid van de unit
	zou moeten beïnvloeden, dus in de functie getMovementSpeed() roep ik deze functie op

uit IFacade: Your <code>Facade</code> class should offer a <b>default constructor

alternatieve optie:
in world geen set aanmaken van units om opslagruimte te besparen, en dan om alle units op te vragen
via getAllUnits itereren over alle factions.
mogelijke nadelen:
1) Als ik dan in een functie getAllUnits gebruik om er weer over te itereren, 
worden het misschien te veel iteraties over elkaar?
2) addUnit wordt ingewikkelder, maar addFaction mss juist makkelijker
	-> hmm, ik denk dat dit super ingewikkeld gaat worden... het porbleem is vooral of de klasse world dan wel de
	methodes van unit gaat ondersteunen

ik dacht om deze invariant te gebruiken en dus als een faction leeg is, die direct weg te halen 
uit de world (faction.world wordt dan null)
@invar	Each faction in a world should always be active, i.e. non-empty
	-> heb ik ook aan gedacht, het zou sowieso geheugen besparen, maar er wordt in de opgave nergens gezegd dat er een
	terminate() methode voor faction moet bestaan. En ik heb geen idee of dit ooit nog problemen kan geven. We moeten
	dit eens bekijken
	
we moeten alle commentaar in unit nog nakijken...

DOODGAAN UNIT: een unit moet dus doodgaan van zodra de hitpoints 0 zijn. Momenteel checkt
advanceTime() op het einde of de hitpoints 0 zijn en laat dan de unit doodgaan. Is het een
beter idee om bij de setHitpoints(hitpoints) een if (hitpoints == 0) -> this.die() te doen?

TODO's die in unit bovenaan stonden:
/**
 * TODO:
 * regular expressions (name)
 * fuzzyequals gebruiken in documentatie en testen
 * documentatie schrijven
 * testen schrijven
 * user interface aan de praat krijgen (hihi, nu terug een TODO)
 * null pointers (niet nodig voor primary attributes, want int is basic type) (OK voor name) -> zeker nog nachecken!
 */
 
 METHODES CUBE/WORLD: nu staan enkele methoden voor cubes in world (vb: world.methodeVoorCube(cube))
 en andere methodes staan in cube (vb cube.methodeVoorCube(world)) -> moeten we hier niet consistent
 in zijn en alle methodes in 1 klasse zetten?
 
 OMG IK HAD IN DE OPDRZCHT ERGENS OVER GELEZEN: oke dit is geen ramp, gewoon nog een beetje werk dat ik niet
 verwacht had, activity is nu een lijst (omdat een unit na vallen/vechten zijn vorige activiteit zou moeten kunnen
 verderzetten, en moet kunnen lopen naar een cube om er dan op te werken enzo
 
 	// TODO ik dacht om deze invariant te gebruiken en dus als een faction leeg
	// is, die direct weg te halen
	// uit de world (faction.world wordt dan null)
	// @invar Each faction in a world should always be active, i.e. non-empty
	// -> zie txt bestand opmerkingen, dat kan in principe, zou geheugen
	// besparen, maar de rvaag is of dat ooit problemen met iets gaat geven
	
ik heb eens getest op de workshop: geen errors, de units verhogen weight
(niets bij toughness, maar dat wisten we al zeker)
probleem is nog dat ze de boulder en log ook terug vastnemen

voorlopig kunnen we materials aanmaken, zonder dat die log of boulder zijn, dat zou niet mogen

